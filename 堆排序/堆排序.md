# 堆排序

## 堆排序算法思想

堆排序（Heap Sort）是一种基于**堆数据结构**的排序算法。堆是一种 **完全二叉树** ，满足以下特点：

* **最大堆（Max Heap）** : 每个父节点的值都大于或等于其子节点的值。
* **最小堆（Min Heap）** : 每个父节点的值都小于或等于其子节点的值。

堆排序通常使用**最大堆**来实现升序排序。其主要思想是通过构建最大堆，将最大值（堆顶元素）移到数组末尾，然后重新调整堆结构，继续取最大值。这一过程不断重复，最终完成排序。

## 堆排序的步骤解析

1. **构建最大堆** :

   * 将数组转换成一个最大堆，使得根节点是整个数组的最大值。
   * 从最后一个非叶子节点开始向上调整，使每个子树都满足最大堆的性质。
2. **交换堆顶和末尾元素** :

   * 将堆顶（最大值）与数组的最后一个元素交换，使得最大值被移到正确的位置。
   * 这样，最后一个元素不再参与接下来的堆调整。
3. **调整堆结构** :

   * 去除已排序的最后一个元素后，对剩下的元素重新进行堆调整，以保持最大堆的性质。
   * 重复步骤 2 和 3，直到数组完全排序。

### 构建最大堆

#### 完全二叉树的特性

数组形式的堆（完全二叉树）中，节点的索引与其左右子节点的索引有固定关系：

- 对于节点索引 `i`：
  - 左子节点的索引是 `2 * i + 1`
  - 右子节点的索引是 `2 * i + 2`

在一个完全二叉树中：

- **叶节点**（没有子节点的节点）位于数组的后半部分。
- **非叶节点**位于数组的前半部分。

假设数组长度为 `n`：

- 从索引 `Math.floor(n / 2)` 开始到 `n - 1` 的节点都是叶节点，因为这些节点没有子节点，不需要进行 `heapify` 调整。
- 因此，只有从索引 `Math.floor(n / 2) - 1` 到 `0` 的节点才需要进行 `heapify` 操作。

#### 构建最大堆的整体思路

1. **从最后一个非叶节点开始**：由于叶节点没有子节点，不需要调整。可以从数组的最后一个非叶节点开始，逐步向前遍历并对每个节点进行 `heapify`。
2. **递归调整**：每个节点调用 `buildMaxHeap` 函数，确保当前节点及其子树满足最大堆的性质。
3. **自底向上构建堆**：从底部逐层向上调整子树为最大堆，最终整个树成为最大堆。

#### 步骤解析

假设我们有一个数组 `arr`，它的长度为 `n`，下面是构建最大堆的具体步骤：

1. **确定第一个需要 `heapify` 的节点**：
   - 从最后一个非叶节点开始调用 `heapify` 函数。最后一个非叶节点的索引是 `Math.floor(n / 2) - 1`。
2. **从第一个非叶节点向前遍历**：
   - 对于每个节点 `i`（从 `Math.floor(n / 2) - 1` 到 `0`），调用 `heapify`，调整当前节点与其子节点，使以 `i` 为根的子树成为一个最大堆。
3. **`heapify` 调整过程**：
   - 比较节点 `i` 的值与其左、右子节点的值，找到最大值所在的节点。
   - 如果子节点的值大于当前节点，则交换它们，并继续对新的子树进行 `heapify` 调整，确保子树满足最大堆的性质。

#### `buildMaxHeap` 过程（单个节点的调整）

假设当前节点的索引为 `i`，其左子节点和右子节点的索引分别为 `2 * i + 1` 和 `2 * i + 2`。以下是 `heapify` 的具体步骤：

1. **初始化最大值**：
   - 设 `largest = i`，即当前节点先假设为最大值。
2. **与左子节点比较**：
   - 如果左子节点存在（索引 `2 * i + 1 < n`）并且左子节点的值大于 `arr[largest]`，则更新 `largest = 2 * i + 1`。
3. **与右子节点比较**：
   - 如果右子节点存在（索引 `2 * i + 2 < n`）并且右子节点的值大于 `arr[largest]`，则更新 `largest = 2 * i + 2`。
4. **判断是否需要交换**：
   - 如果 `largest` 不等于 `i`（说明子节点有更大的值），则交换 `arr[i]` 和 `arr[largest]`，使得 `arr[i]` 成为以 `i` 为根的子树的最大值。
5. **递归调用**：
   - 如果发生了交换，对 `largest` 位置递归调用 `heapify`，确保调整后的子树也满足最大堆的性质。



## 算法复杂度分析

1. **时间复杂度** :

   * **最坏时间复杂度** : O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。
     * 建堆过程的时间复杂度是 O(n)O(n)**O**(**n**)，因为每个节点都需要“下沉”操作。
     * 堆排序过程有 n−1n - 1**n**−**1** 次调整，每次调整的时间复杂度为 O(log⁡n)O(\log n)**O**(**lo**g**n**)。
   * **平均时间复杂度** : O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。在各种情况下，堆排序都表现得比较稳定。
   * **最好时间复杂度** : O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。即使数组已经有序，也需要通过建堆和调整。
2. **空间复杂度** :

   * **空间复杂度** : O(1)O(1)**O**(**1**)。堆排序是原地排序算法，不需要额外的存储空间。
3. **稳定性** :

   * **不稳定** : 堆排序是**不稳定**的，因为在交换时可能改变相同元素的相对顺序。

## 堆排序的适用场景

1. **需要原地排序** :

   * 当内存空间非常有限时，堆排序由于其 O(1)O(1)**O**(**1**) 的空间复杂度表现良好。
2. **大规模数据** :

   * 堆排序在处理大量数据时，能保证 O(nlog⁡n)O(n \log n)**O**(**n**log**n**) 的时间复杂度，不会像快速排序那样在最坏情况下退化为 O(n2)O(n^2)**O**(**n**2**)**。
3. **在线应用** :

   * 堆排序的构造过程类似于堆数据结构中的优先队列，可以在线应用中处理不断输入的数据。
