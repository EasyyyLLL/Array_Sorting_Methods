# 归并排序

## 归并排序算法思想

归并排序（Merge Sort）是一种 **分治法** （Divide and Conquer）的排序算法。它的基本思想是将数组不断地拆分成较小的子数组，直到每个子数组只有一个元素（自然是有序的）。然后，将这些有序的子数组**合并**成一个更大的有序数组，最终得到一个排序完成的数组。

 **基本思想** :

1. **分解** :

   * 将数组从中间分成两个子数组，递归地对子数组进行分解，直到每个子数组只有一个元素。
2. **合并** :

   * 将两个有序的子数组合并成一个有序数组。
3. **递归** :

   * 重复上述过程，最终合并所有的子数组。

## 归并排序的步骤解析

1. **递归分解** :

   * 将数组从中间分成两半，递归地对左半部分和右半部分进行排序。
   * 递归调用的结束条件是数组的长度小于或等于1，这时数组已经是有序的。
2. **合并操作** :

   * 使用一个辅助函数，将两个有序的子数组合并成一个更大的有序数组。
   * 比较两个子数组的元素，将较小的元素放入结果数组中。
3. **重复合并** :

   * 递归地合并分解的数组，最终得到排序后的完整数组。

## 算法复杂度分析

1. **时间复杂度** :

   * **最坏时间复杂度** : O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。在每一级递归中，我们会将数组一分为二，因此递归的深度是 log⁡n\log n**lo**g**n**。每一级的合并操作是线性的，所以总时间复杂度为 O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。
   * **平均时间复杂度** : O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。对于随机数组，归并排序的性能表现是稳定的。
   * **最好时间复杂度** : O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。即使数组已经有序，归并排序的分解和合并过程仍然是 O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。
2. **空间复杂度** :

   * **空间复杂度** : O(n)O(n)**O**(**n**)。由于在合并操作中，需要额外的数组来存放排序结果，因此归并排序的空间复杂度是线性的。这是它与快速排序的一个主要区别（快速排序的空间复杂度为 O(log⁡n)O(\log n)**O**(**lo**g**n**)）。
3. **稳定性** :

   * **稳定** : 归并排序是稳定的排序算法，因为在合并两个子数组时，相同的元素不会改变它们在原数组中的相对位置。


## 归并排序的适用场景

1. **大规模数据** :

   * 归并排序非常适合处理大规模数据，因为它的时间复杂度始终是 O(nlog⁡n)O(n \log n)**O**(**n**log**n**)。
2. **链表排序** :

   * 归并排序非常适合用于链表，因为它不需要随机访问，而是通过指针操作，因此可以直接对链表进行排序。
3. **稳定性要求高的情况** :

   * 当需要保持相同元素的相对顺序时，可以选择归并排序。
